vim.g.mapleader = " "
--------------
-- Mappings --
--------------

-- disable netrw at the very start of your init.lua (strongly advised)
vim.g.loaded_netrw = 1
vim.g.loaded_netrwPlugin = 1


-- Convenience
local function map(mode, shortcut, command)
  vim.keymap.set(mode, shortcut, command, { noremap = true, silent = true })
end

local function nmap(shortcut, command)
  map("n", shortcut, command)
end

local function imap(shortcut, command)
  map("i", shortcut, command)
end

local function vmap(shortcut, command)
  map("v", shortcut, command)
end

-- Normal mode mappings
nmap("<TAB>", ":bnext<CR>")                -- TAB to next buffer
nmap("<S-TAB>", ":bprevious<CR>")          -- Shift + TAB to prev buffer
nmap("<C-s>", ":write<cr>")                -- Save
nmap("<Leader>d", '"_d')                   -- Blackhole register
nmap("<Leader>p", "$p<cr>")                -- Paste to end of line
nmap("<Leader>s", ":%s/\\<<C-r><C-w>\\>/") -- Search-replace word in file
nmap("<Leader>x", ":bdelete<cr>")          -- Close buffer
nmap("<Leader>y", '"+y')                   -- Copy to system clipboard

-- Visual mode mappings
vmap("<", "<gv")                  -- Keep visual selection when indenting forward
vmap(">", ">gv")                  -- Keep visual selection when indenting backward
vmap("<Leader>j", "!jq '.' <CR>") -- Format JSON under visual selection

--------------
-- Settings --
--------------

vim.opt.termguicolors = true
vim.opt.background = "dark"
vim.cmd("set hidden")
vim.opt.mouse = "a"

vim.opt.cmdheight = 1
vim.opt.completeopt = { "menuone", "noselect" }
vim.opt.number = true
vim.opt.updatetime = 50
vim.opt.splitbelow = true
vim.opt.splitright = true
vim.opt.scrolloff = 8

-- Search options
vim.opt.hlsearch = false
vim.opt.ignorecase = true
vim.opt.smartcase = true

vim.opt.autoindent = true
vim.cmd("set expandtab")

vim.opt.list = true
vim.opt.listchars = { tab = "> ", trail = "·", nbsp = "+" }

------------------
-- Autocommands --
------------------

-- Whenever plugins.lua is updated, re-compile
vim.cmd([[
augroup packer_auto_compile
  autocmd!
  autocmd BufWritePost */nvim/lua/plugins.lua source <afile> | PackerCompile
augroup END
]])

-- Dotfile management
-- Run chezmoi apply whenever you save a dotfile
-- Auto source when writing to init.lua alternatively you can run :source $MYVIMRC
vim.cmd([[
augroup dotfiles
  au! BufWritePost ~/.local/share/chezmoi/* ! chezmoi apply
  au! BufWritePost $MYVIMRC source %
augroup END
]])

-- Remove trailing spaces in yaml
vim.cmd([[
augroup dotfiles
  au! BufWritePre *.yaml %s/\s\+$//e
  au! BufWritePre *.yml %s/\s\+$//e
augroup END
]])

-- Highlight yank
vim.api.nvim_create_autocmd(
  { "TextYankPost" },
  { pattern = { "*" }, command = "lua require'vim.highlight'.on_yank()" }
)

-- Highlight all search matches only while typing
vim.cmd([[
augroup vimrc-incsearch-highlight
  autocmd!
  autocmd CmdlineEnter /,\? :set hlsearch
  autocmd CmdlineLeave /,\? :set nohlsearch
augroup END
]])

-------------
-- Plugins --
-------------

-- Installs plugins
require("plugins")

vim.cmd('cabbrev wq execute "Format sync" <bar> wq')

-- Configure LSP
require("lsp")
require("mason").setup()
require("mason-tool-installer").setup {

  -- a list of all tools you want to ensure are installed upon
  -- start; they should be the names Mason uses for each tool
  ensure_installed = {
    -- you can pin a tool to a particular version
    -- { "golangci-lint", version = "v1.47.0" },
    -- you can turn off/on auto_update per tool
    -- { "bash-language-server", auto_update = true },
    "ansible-language-server",
    "json-lsp",
    "lua-language-server",
    "pyright",
    "rust-analyzer",
    "shellcheck",
    "typescript-language-server",
    "yaml-language-server",
  },

  -- if set to true this will check each tool for updates. If updates
  -- are available the tool will be updated. This setting does not
  -- affect :MasonToolsUpdate or :MasonToolsInstall.
  -- Default: false
  auto_update = true,

  -- automatically install / update on startup. If set to false nothing
  -- will happen on startup. You can use :MasonToolsInstall or
  -- :MasonToolsUpdate to install tools and check for updates.
  -- Default: true
  run_on_start = true,
  start_delay = 3000, -- 3 second delay
  debounce_hours = 5, -- at least 5 hours between attempts to install/update
}

vim.cmd('let g:go_fmt_command = "gofmt"')

-- Telescope fuzzy finder
require("telescope").setup {
  defaults = {
    -- Default configuration for telescope goes here:
    -- config_key = value,
    mappings = {
      i = {
        -- map actions.which_key to <C-h> (default: <C-/>)
        -- actions.which_key shows the mappings for your picker,
        -- e.g. git_{create, delete, ...}_branch for the git_branches picker
        ["<C-h>"] = "which_key"
      }
    }
  },
  colorscheme = "auto",
}

-- [[ Configure Treesitter ]]
-- See `:help nvim-treesitter`
require("nvim-treesitter.configs").setup {
  -- Add languages to be installed here that you want installed for treesitter
  ensure_installed = { "c", "go", "lua", "python", "rust", "javascript", "typescript", "vim" },

  highlight = { enable = true },
  indent = { enable = true, disable = { "python" } },
  incremental_selection = {
    enable = true,
    keymaps = {
      init_selection = "<c-space>",
      node_incremental = "<c-space>",
      scope_incremental = "<c-s>",
      node_decremental = "<c-backspace>",
    },
  },
  textobjects = {
    select = {
      enable = true,
      lookahead = true, -- Automatically jump forward to textobj, similar to targets.vim
      keymaps = {
        -- You can use the capture groups defined in textobjects.scm
        ["aa"] = "@parameter.outer",
        ["ia"] = "@parameter.inner",
        ["af"] = "@function.outer",
        ["if"] = "@function.inner",
        ["ac"] = "@class.outer",
        ["ic"] = "@class.inner",
      },
    },
    move = {
      enable = true,
      set_jumps = true, -- whether to set jumps in the jumplist
      goto_next_start = {
        ["]m"] = "@function.outer",
        ["]]"] = "@class.outer",
      },
      goto_next_end = {
        ["]M"] = "@function.outer",
        ["]["] = "@class.outer",
      },
      goto_previous_start = {
        ["[m"] = "@function.outer",
        ["[["] = "@class.outer",
      },
      goto_previous_end = {
        ["[M"] = "@function.outer",
        ["[]"] = "@class.outer",
      },
    },
    swap = {
      enable = true,
      swap_next = {
        ["<leader>a"] = "@parameter.inner",
      },
      swap_previous = {
        ["<leader>A"] = "@parameter.inner",
      },
    },
  },
}

-- File tree
require("nvim-tree").setup({
  sort_by = "case_sensitive",
  view = {
    adaptive_size = true,
    mappings = {
      list = {
        { key = "u", action = "dir_up" },
      },
    },
  },
  renderer = {
    group_empty = true,
  },
  filters = {
    dotfiles = true,
  },
})


-- Gitsigns
-- See `:help gitsigns.txt`
require("gitsigns").setup {
  signs = {
    add = { text = "+" },
    change = { text = "~" },
    delete = { text = "_" },
    topdelete = { text = "‾" },
    changedelete = { text = "~" },
  },
}

-- nvim-cmp setup
local cmp = require("cmp")
local luasnip = require("luasnip")

cmp.setup {
  snippet = {
    expand = function(args)
      luasnip.lsp_expand(args.body)
    end,
  },
  mapping = cmp.mapping.preset.insert {
    ["<C-Space>"] = cmp.mapping.confirm(),
    ["<C-d>"] = cmp.mapping.scroll_docs(-4),
    ["<C-f>"] = cmp.mapping.scroll_docs(4),
    ["<CR>"] = cmp.mapping.confirm {
      behavior = cmp.ConfirmBehavior.Replace,
      select = true,
    },
    ["<Tab>"] = cmp.mapping(function(fallback)
      if cmp.visible() then
        cmp.select_next_item()
      elseif luasnip.expand_or_jumpable() then
        luasnip.expand_or_jump()
      else
        fallback()
      end
    end, { "i", "s" }),
    ["<S-Tab>"] = cmp.mapping(function(fallback)
      if cmp.visible() then
        cmp.select_prev_item()
      elseif luasnip.jumpable(-1) then
        luasnip.jump(-1)
      else
        fallback()
      end
    end, { "i", "s" }),
  },
  sources = {
    { name = "nvim_lsp" },
    { name = "luasnip" },
  },
}

require("nvim-lastplace").setup {
  lastplace_ignore_buftype = { "quickfix", "nofile", "help" },
  lastplace_ignore_filetype = { "gitcommit", "gitrebase", "svn", "hgcommit" },
  lastplace_open_folds = true
}
---------------------
-- Plugin Mappings --
---------------------

-- Telescope
local builtin = require("telescope.builtin")
nmap("<Leader>fb", builtin.buffers)
nmap("<Leader>ff", builtin.find_files)
nmap("<Leader>fg", builtin.live_grep)
nmap("<Leader>fh", builtin.help_tags)
nmap("<Leader>fw", builtin.grep_string)

-- Git - vim-fugitive
nmap("<Leader>gb", ":Git blame<cr>")  -- git blame %
nmap("<Leader>gw", ":Gwrite<cr>")     -- git add %
nmap("<Leader>gc", ":Git commit<cr>") -- git commit
nmap("<Leader>grm", ":Gremove<cr>")   -- git rm %
nmap('<Leader>gmv', ':Gmove ')        -- git mv <path>

vim.cmd("let g:fugitive_gitlab_domains = {'ssh://git.2nd.io': 'https://git.2nd.io'}")

nmap("<Leader>o", ":NvimTreeFindFileToggle<CR>") -- open file explorer

-- colorschemin' last because I mess it up a lot when I switch
-- vim.g.material_style = "darker" -- when colorscheme == material
local colorscheme = "{{ .nvim_colorscheme }}"
local ok, _ = pcall(vim.cmd, "colorscheme " .. colorscheme)
if not ok then
  vim.notify("colorscheme " .. colorscheme .. " not found!")
  return
end
